<link rel="import" href="../components/polymer/polymer-element.html">
<link rel="import" href="../components/app-localize-behavior/app-localize-behavior.html">
<link rel="import" href="./status-bar.html">
<link rel="import" href="./modal.html">


<dom-module id="line-v-card">

  <template>
    <style>
      :host {
        overflow: hidden;
      }
      line {
        stroke: #2ECC98;
        stroke-width: 3px;
        stroke-linecap: round;
        marker-end: url(#marker);
      }
      circle {
        cursor: pointer;
      }
    </style>
    <status-bar
      title="{{localize('title')}}"
      score="{{localize('score')}}"
      lefted="{{localize('lefted')}}"
      hasname="{{handleCheckName()}}"
      total="{{total}}"
      point="{{point}}"
      matched="{{matched}}"
      cards="{{cards}}"
      on-modal="handleModal"
      purpose="line"
      ></status-bar>
    <toycode-modal
      id="successModal"
      purpose="nextStep"
      headertext="{{localize('successHead')}}"
      btmtext="{{localize('successBtm')}}"
      total="{{total}}"
      point="{{point}}"
      matched="{{matched}}"
      nextbtn="{{localize('nextbtn')}}"
      ></toycode-modal>
    <toycode-modal
      id="logOutModal"
      headertext="{{localize('logoutHead')}}"
      btmtext="{{localize('logoutBtm')}}"
      yesbtn="{{localize('yesbtn')}}"
      nobtn="{{localize('nobtn')}}"
      purpose="logout"
      ></toycode-modal>
    <toycode-modal
      id="previousModal"
      headertext="{{localize('previousHead')}}"
      btmtext="{{localize('previousBtm')}}"
      yesbtn="{{localize('yesbtn')}}"
      nobtn="{{localize('nobtn')}}"
      purpose="previous"
      ></toycode-modal>
    <toycode-modal
      id="finalStageModal"
      headertext="{{localize('finalStageHead')}}"
      btmtext="{{localize('finalStageBtm')}}"
      finalbtn="{{localize('finalbtn')}}"
      purpose="finalStage"
      nextlink="{{nextlink}}"
      ></toycode-modal>
  </template>
  <script>
    class LineVCard extends Polymer.mixinBehaviors([Polymer.AppLocalizeBehavior], Polymer.Element) {
      static get is() { return 'line-v-card'; }
      connectedCallback() {
        super.connectedCallback();
      }
      static get properties() {
        return {
          language: {
            value: "ko"
          },
          resources: {
            value() {
              return {
                "ko": {
                  "title": "짝 맞추기",
                  "success": "참 잘했어요!"
                },
                "en": {
                  "title": "Match the Pairs 2",
                  "success": "Good job!"
                }
              }
            }
          }
        }
      }
      ready() {
        super.ready();
        this.set('total', 0)
        this.set('point', 0)
        this.set('matched', 0)
        this.set('stage', 1)
      }
      reset(){
        this.set('total', 0)
        this.set('matched', 0)
        this.set('point', this.point+5)
        this.set('stage', this.stage+1)
        d3.select(this.shadowRoot).select('svg').remove()
        this.setData(this.data, this.manifest)
      }
      handleCheckName(){
        if(window.name){
          return true
        } else return false
      }
      handleModal(e) {
        if(e.detail.purpose === "previous") {
          this.$.previousModal.modalAlert();
        } else {
          this.$.logOutModal.modalAlert();
        }
      }
      setData(data, manifest){
        let _this = this,
            svg = d3.select(this.shadowRoot).append('svg')
              .attr('width', this.offsetWidth)
              .attr('height', `${this.offsetHeight-60}`),
            boardName = ["boardL", "boardR"];
        let max = this.max ? this.max : manifest.length/2,
            leftData = d3.shuffle(manifest.filter(l => !l.set).map(l => ({["no"]:l.no, ["src"]:l.src}))).slice(0, max),
            after = manifest.filter(l => l.set),
            randomLang = leftData.map(o => o.no), rightData = [];
            randomLang.map(i => (after.forEach(l => l.no === i && rightData.push({["no"]: l.no, ["src"]:l.src}))))


        this.set('cards', max)
        this.set('data', data )
        this.set('manifest', manifest )


        let defs = svg.append('defs').selectAll('pattern')
        let shuf_left = d3.shuffle(leftData), shuf_right = d3.shuffle(rightData)
        let leftCard = defs.data(shuf_left).enter()
          .append('pattern')
          .attr("id", (d, i) => `left_${d.no}`)
          .attr("x", 0).attr("y", 0)
          .attr("width", 1).attr("height", 1)
          .attr("patternUnits", "objectBoundingBox");


        svg.append('svg:defs').append('svg:marker')
            .attr('id', 'marker')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 6)
            .attr('markerWidth', 3)
            .attr('markerHeight', 3)
            .attr('orient', 'auto')
            .append('svg:path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#2ECC98');


        leftCard.append('filter')
          .attr('id','desaturate')
          .append('feColorMatrix')

        leftCard.append('image')
          .attr("x", 5).attr("y", 5)
          .attr("width", 100).attr("height", 100)
          .attr("xlink:href", d => `${d.src}`)
          .style('filter', "url(#desaturate)")


        let rightCard = defs.data(shuf_right).enter()
          .append('pattern')
          .attr("id", (d, i) => `right_${d.no}`)
          .attr("x", 0).attr("y", 0)
          .attr("width", 1).attr("height", 1)
          .attr("patternUnits", "objectBoundingBox")
          .append('image')
          .attr("x", 5).attr("y", 5)
          .attr("width", 100).attr("height", 100)
          .attr("xlink:href", (d, i) => `${d.src}`)

        let center = (this.offsetWidth - 560)/2
        let rectGroup = svg.selectAll("g")
          .data(boardName).enter()
          .append("g")
          .attr("class", d => `${d}`)
          .attr("transform", (d, i) => `translate(${center}, 0)`);

        let LeftSide = svg.select('.boardL');
        LeftSide.selectAll("rect")
            .data(shuf_left).enter()
            .append('rect')
            .attr("rx", 5).attr("ry", 5)
            .attr('x', 10 ).attr('y', (d, i) => (110*i+10) + (30*i))
            .attr("width", 110).attr("height", 110)
            .style("fill", (d,i) => `url(#left_${d.no})`)


        let circlesL = LeftSide.selectAll("g.node")
          .data(shuf_left).enter()
          .append('g')
          .attr("transform", (d, i) => `translate( 140 , ${65+ 140*i})`)


        circlesL.append("circle").attr("r", 5)
        let click = circlesL.append("circle")
          .attr("r", 60).attr("opacity", 0.0)
          .attr('id', (d) => `touch${d.no}`)

        click.on("mousedown touchstart", pencilingStart )

        svg.on("mouseup touchend", pencilingEnd)

        let RightSide = svg.select('.boardR');
        RightSide.selectAll("rect")
            .data(shuf_right).enter()
            .append('rect')
            .attr("rx", 5).attr("ry", 5)
                .attr('x', 450 ).attr('y', (d, i) => (110*i+10) + (30*i))
            .attr("width", 110).attr("height", 110)
            .style("fill", "#fff")
            .style("fill", (d,i) => `url(#right_${d.no})`)
            // .style("stroke-width",8)
            // .style("stroke","#2ECC98")


        RightSide.selectAll("g")
            .data(shuf_right).enter()


        let circlesR = RightSide.selectAll("g.node")
          .data(shuf_right).enter()
          .append('g')
          .attr("transform", (d, i) => `translate( 430 , ${65+ 140*i})`)
          .attr("id", (d, i) => `matchId${d.no}`)

        // 라인이 매칭되는 포인트
        circlesR.append("circle").attr("r", 5).attr('pointer-events', 'none');
        // 라인이 매칭되는 범위를 지정하는 포인트
        // circlesR.append("circle").attr("r", 25).attr("opacity", 0.0)


        var line;
        let dragId, dropId, startX, startY;

        function pencilingStart (d, i) {
          let getXY = d3.select(this.parentElement).attr("transform").match(/\d+/g),
              numX = center+parseInt(getXY[0], 10),
              numY = parseInt(getXY[1], 10);
              startX = numX;
              startY = numY;

          console.log(getXY, numX, numY,  startX, startY, center);

          dragId = d.no;
          line = svg.append("line")
                .attr("x1", numX).attr("y1", numY)
                .attr("x2", numX).attr("y2", numY)
                .attr("id", (d, i) => `line${dragId}`);
          svg.on("mousemove touchmove", pencilingMove);
        }

        function pencilingMove(d) {
          let m = d3.mouse(this);
          line.attr("x2", m[0]).attr("y2", m[1]);
        }

        function pencilingEnd() {
          if (dragId === undefined) return false
          let filterItems = svg.select('.boardR').node().childNodes,
              dropItems = [];

          filterItems.forEach(el => {
            if(el.tagName === "rect") dropItems.push(el)
          })


          let targetEl, targetX, targetY, targetX2, targetY2;
          let getArrow = d3.select(this).select(`#line${dragId}`);
          dropItems.forEach(el => {
            const getEl = el.getBoundingClientRect();
            let getX = +getArrow.attr('x2')+getEl.width/2,
                getY = +getArrow.attr('y2')+getEl.height/2;
            // 범위 확인
            if(getEl.left < getX && getX < getEl.right && getEl.top < getY && getY < getEl.bottom) {
              targetEl = el;
              targetX = getEl.x;
              targetY = getEl.y;
              dropId = targetEl.__data__.no;
            }
            console.log(getX, getY, dropId, targetX, targetY);
          });

          if(dragId === dropId) {
            let getXY = d3.select(_this.shadowRoot).select(`#matchId${dropId}`).attr("transform").match(/\d+/g),
                numX = center+parseInt(getXY[0], 10),
                numY = parseInt(getXY[1], 10);

            line.attr("x2", numX).attr("y2", numY);
            console.log("its matched!!!", numX, numY)
            d3.select(_this.shadowRoot).select(`#touch${dragId}`)
              .on("mousedown touchstart", false )
            _this.set('matched', _this.matched+1)
            _this.set('point', _this.point+2)


          } else {
            console.log("itsnt matched!!!", startX, startY, dragId, dropId)
            line.remove();
          }
           _this.set('total', _this.total+1)
           dragId = undefined;
           svg.on("mousemove touchmove", null);
           if(_this.matched === _this.cards) {
             _this.stage === _this.lastStage ? _this.$.finalStageModal.modalAlert() : _this.$.successModal.modalAlert()
           }
        }
      }
    }
    window.customElements.define(LineVCard.is, LineVCard);
  </script>
</dom-module>
