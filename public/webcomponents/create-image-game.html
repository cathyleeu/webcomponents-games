<link rel="import" href="../components/polymer/polymer-element.html">
<link rel="import" href="../components/app-localize-behavior/app-localize-behavior.html">
<link rel="import" href="./status-bar.html">
<link rel="import" href="./button.html">
<link rel="import" href="./modal.html">


<dom-module id="create-image-game">
  <template>
    <style>
    </style>
    <status-bar
      id="statusBar"
      title="{{localize('title')}}"
      score="{{localize('score')}}"
      lefted="{{localize('lefted')}}"
      hasname="{{handleCheckName()}}"
      total="{{total}}"
      point="{{point}}"
      matched="{{matched}}"
      purpose="select"
      cards="{{cards}}"
      on-modal="handleModal"
      fullscreen="{{localize('fullscreen')}}"
    ></status-bar>
    <toycode-modal
      id="unCorrectModal"
      purpose="unCorrect"
      filter-Images="{{filterUncorrectImages}}"
      headertext="{{localize('retryHead')}}"
      btmtext="{{localize('unCorrect')}}"
      retrybtn="{{localize('retrybtn')}}"
      ></toycode-modal>
    <toycode-modal
      id="retryModal"
      purpose="retry"
      headertext="{{localize('retryHead')}}"
      btmtext="{{localize('retryBtm')}}"
      retrybtn="{{localize('retrybtn')}}"
      ></toycode-modal>
    <toycode-modal
      id="finalStageModal"
      headertext="{{localize('finalStageHead')}}"
      btmtext="{{localize('finalStageBtm')}}"
      finalbtn="{{localize('finalbtn')}}"
      purpose="finalStage"
      nextlink="{{nextlink}}"
      ></toycode-modal>
    <toycode-button button-Data="[[dispatchToChild()]]"></toycode-button>

      <svg id="createSvg"></svg>
      <canvas id="canvas" style="display:none;"></canvas>
  </template>
  <script>
    class CreateImageGame extends Polymer.mixinBehaviors([Polymer.AppLocalizeBehavior], Polymer.Element) {
      static get is() { return 'create-image-game'; }
      connectedCallback() {
        super.connectedCallback();
      }
      static get properties() {
        return {
          language: {
            value: "ko"
          }
        }
      }
      ready() {
        super.ready();
        let { innerHeight, innerWidth } = window,
            size = {
              svgHeight : innerHeight-this.$.statusBar.getBoundingClientRect().height
            }
            size["boardSize"] = innerWidth*0.6 > size.svgHeight ? size.svgHeight : innerWidth*0.6;
            size["resWidth"] = innerWidth-size.boardSize;
            size["imageItemSize"] = size.boardSize/7;
            size["svgHeight"] = size.boardSize;
            size["boardImageCenter"] = (size.svgHeight-size.boardSize)/2;
            size["reAxis"] = size.boardSize/100;

        this.set("size", size)
        this.updateStyles({
          '--toycode-button-container-padding' : `${size.resWidth*0.1}px`,
          '--toycode-button-container-width': `${size.resWidth}px`,
        })
        this.set('correct', [])
        this.set('unCorrect', [])
      }
      reset(){
        let ele = d3.select('#element').node();
        d3.select(ele.$.createSvg).selectAll('image, g').remove()
        ele.setData(ele.data, ele.manifest)
        ele.set('correct', [])
        ele.set('unCorrect', [])
      }
      dispatchToChild(){
        let button = [
          { text: "출력하기", method: this.exportImage },
          { text: "다시하기", method: this.reset },
          { text: "완성하기", method: this.handleStageClear },
        ]
        return button
      }
      exportImage(){
        // FIXME: 이미지 크기 조정
        // debugger
        let element = d3.select('#element').node(),
            svg = d3.select(element.shadowRoot).select("#createSvg").node();
        // console.log("exportImage");

        let targetNodes = []
        svg.childNodes.forEach(el => {
          if(el.id === "background" || el.dataset.item){
            targetNodes.push(el)
          }
        })
        let { boardSize, imageItemSize } = element.size;
        var canvas = d3.select(element.shadowRoot).select("#canvas").node();
        canvas.width = element.size.boardSize;
        canvas.height = element.size.boardSize;
        var ctx = canvas.getContext("2d");
        targetNodes.forEach((el) => {
          let { x, y, width, height } = el.getBBox()
          let img = new Image();
              img.src = el.href.animVal;
          let imgRatio = el.id === "background" ? img.width/boardSize : img.width/imageItemSize
          ctx.drawImage( img, 0, 0, width*imgRatio, height*imgRatio, x, y, width, height )
        })
        var png = canvas.toDataURL("image/png");
        var link = document.createElement("a");
        link.href = png;
        link.download = "";
        link.click();
        link = null
      }
      filterUncorrectImages(){
        let element = d3.select('#element').node(),
            {unCorrect, items} = element;
        // console.log(unCorrect, items)
        return unCorrect.map(un => items.find(ele => ele.name === un))
      }
      handleStageClear(){
        let element = d3.select('#element').node(),
            svg = d3.select(element.shadowRoot).select("#createSvg").node(),
            { unCorrect, correct, items} = element;

        let used = element.circleDom.filter(dom => dom.dataset.circle === "used").length
        if(this.limited) {
          if(used !== items.length) {
            element.$.retryModal.modalAlert()
            return false;
          }
          if(unCorrect.length > 0) {
            element.$.unCorrectModal.modalAlert()
            return false;
          }
        }
        element.$.finalStageModal.modalAlert()
      }
      filterMatch(name, status) {
        let opposite = status === 'correct' ? 'unCorrect' : 'correct',
            target = this[opposite].indexOf(name);
        if( target !== -1) {
          this.set( opposite , this[opposite].filter(mat => mat !== name))
        }
        this[status].push(name)
      }
      dragstarted(d) {
        let self = d3.select('#element').node(),
            { imageItemSize } = self.size,
            startX = this.x.animVal.value,
            startY = this.y.animVal.value;

        self.set('startX', startX)
        self.set('startY', startY)
        d3.select(this).attr("x", d3.event.x-(imageItemSize/2)).attr("y", d3.event.y-(imageItemSize/2));
      }
      dragged(d){
        let self = d3.select('#element').node(),
            { imageItemSize } = self.size;
        d3.select(this).attr("x", d3.event.x-(imageItemSize/2)).attr("y", d3.event.y-(imageItemSize/2));
      }
      dragended(d){
        let self = d3.select('#element').node(),
            { imageItemSize } = self.size,
            getX = d3.event.x, getY = d3.event.y;

        let targetEl, targetX, targetY, result;

        self.circleDom.forEach(el => {
          const getEl = el.getBBox();
          if(getEl.x < getX && getX < getEl.x + getEl.height && getEl.y < getY && getY < getEl.y + getEl.height ) {
            if(el.dataset.circle){
              return false
            }
            targetEl = el;
            targetX = getEl.x;
            targetY = getEl.y;
            console.log("%cAAAA"+"%c dragended range true", "background:#ff8772; color:white;", "color:black;");
          }
        })
        // debugger
        if(targetEl){
          if(!this.dataset.item) {
            let rename = this.id.split("_")
            if(!self.limited) {
              d3.select(this.parentElement).append('image').attr("xlink:href", this.href.animVal)
                .attr('width', imageItemSize).attr('height', imageItemSize)
                .attr('id', `${rename[0]}_${+rename[1]+1}`)
                .attr('x', self.startX ).attr('y', self.startY )
                .call(d3.drag()
                  .on("start", self.dragstarted)
                  .on("drag", self.dragged)
                  .on("end", self.dragended)
                );
            }
            d3.select(this).attr("data-item", "used")
          } else {
              let targetCircle = self.circleDom.find(dom => Math.floor(dom.getBBox().x) === Math.floor(self.startX) && Math.floor(dom.getBBox().y) === Math.floor(self.startY))
              d3.select(targetCircle).attr('data-circle', null).attr('data-match', null).attr('data-imageName', null)
          }

          d3.select(this).attr("x", targetX).attr("y", targetY)
        } else {
          console.log("%cBBBB"+"%c drag false", "background:blue; color:white;", "color:black;");
          d3.select(this).attr('x', self.startX ).attr('y', self.startY )
        }

        let { group, name } = d3.event.subject;
        if(group !== targetEl.__data__.group) {
          // match list
          d3.select(targetEl).attr('data-circle', "used")
                       .attr('data-match', "false")
                       .attr('data-imageName', name)

          self.filterMatch(name, 'unCorrect')

        } else {
          d3.select(targetEl).attr('data-circle', "used")
                       .attr('data-match', null)
                       .attr('data-imageName', null)

          self.filterMatch(name, 'correct')

        }
        console.log("%cCCCC"+"%c dragended", "background:purple; color:white;", "color:black;");
      }
      handleSettleItem(d, i){
        let { boardSize, imageItemSize, svgHeight, boardImageCenter, reAxis } = this.size;
         if(d.axis) {
           let targetEl = this.circleDom.find(x => x.__data__[0] === d.axis[0] && x.__data__[1] === d.axis[1])
           d3.select(targetEl).attr("data-circle", "used")
           return d.axis[0]*reAxis-(imageItemSize/2)
         }
         return this.dragItemVerticalMargin+this.axis[i][1]*(imageItemSize)
      }
      setData(data, manifest){

        this.set('data', data)
        this.set('manifest', manifest)

        let { boardSize, imageItemSize, resWidth, svgHeight, boardImageCenter, reAxis } = this.size,
            svg = d3.select(this.$.createSvg).attr('width', innerWidth).attr('height', svgHeight);

        let backgroundImg = manifest.find(d => d.background).src,
            resImagesData = manifest.filter(d => !d.background)

        this.set('items', resImagesData)

        this.set('backgroundImg', backgroundImg)
        let boardImage = svg.append('image')
             .attr("id", "background")
             .attr("xlink:href", backgroundImg)
             .attr('x', 0).attr('y', 0)
             .attr('width', boardSize)
             .attr('height', boardSize)
        boardImage.append('polygon')
                  .attr('style', "fill:lime;stroke:purple;stroke-width:1")
                  .attr('points', "2,157,174,296")
                  .attr('name', 'earth')
                  // style="fill:lime;stroke:purple;stroke-width:1"

        if(this.group){
          let axisObj = []
          this.group.forEach(name => {
            data[name].forEach(arr => axisObj.push({"axis": arr, group: name}))
          })
          data = axisObj
        }

        let cirGroup = svg.selectAll('g')
             .data(data).enter()
             .append('g')
             .attr('data-axis', (d, i) => `dot${i}`)
             .attr("data-group", (d, i) => d.group ? d.group : null )

        cirGroup.append('circle')
           .attr('fill', 'gray')
           .attr("r", 8)
           .attr("cx", (d, i) => d.group ? d.axis[0]*reAxis : d[0]*reAxis )
           .attr("cy", (d, i) => d.group ? d.axis[1]*reAxis : d[1]*reAxis )


        cirGroup.append("circle")
            .attr("r", imageItemSize/2).attr("opacity", 0.0)
            .attr("cx", (d, i) => d.group ? d.axis[0]*reAxis : d[0]*reAxis )
            .attr("cy", (d, i) => d.group ? d.axis[1]*reAxis : d[1]*reAxis )

        this.set('circleDom', cirGroup.nodes())

        let dragItems = resImagesData.length,
            dragItemsRange = Math.floor((resWidth*0.8)/imageItemSize);

        this.set('dragItemVerticalMargin', boardSize+(resWidth-(dragItemsRange*imageItemSize))/2)
        this.set('dragItemHorizontalMargin', (svgHeight-(Math.ceil(dragItems/dragItemsRange)*imageItemSize))/10)

        // debugger
        this.set('axis', [])
        for(var i = 0; i < dragItems; i++ ){
          for(var j = 0; j < dragItemsRange; j++ ) {
            if(this.axis.length >= dragItems) {
              break;
            }
            this.push('axis', [i,j])
          }
        }
        // 위에서 똑같이 data를 부르고 있을때, 새로운 data를 입력할때 전 data 에서 빠져나온후 (exit()) 후 새로운 data().enter()
        let appendImages = svg.selectAll('image').exit()
             .data(resImagesData).enter().append('image')
             .attr("xlink:href", (d, i) => d.src)
             .attr("id", (d,i) => `${d.name}_${i}`)
             .attr('width', `${imageItemSize}`).attr('height', `${imageItemSize}`)
             .attr("data-item", (d, i) => d.axis ? "used" : null)
             .call(d3.drag()
               .on("start", this.dragstarted)
               .on("drag", this.dragged)
               .on("end", this.dragended))
             .attr('x', ( d, i ) => this.handleSettleItem(d, i) )
             .attr('y', ( d, i ) =>
               d.axis
               ? d.axis[1]*reAxis-(imageItemSize/2)
               : this.dragItemHorizontalMargin+this.axis[i][0]*(imageItemSize)
             );

      }
    }
    window.customElements.define(CreateImageGame.is, CreateImageGame);
  </script>
</dom-module>
