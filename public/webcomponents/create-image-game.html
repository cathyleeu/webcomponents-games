<link rel="import" href="../components/polymer/polymer-element.html">
<link rel="import" href="../components/app-localize-behavior/app-localize-behavior.html">
<link rel="import" href="./status-bar.html">
<link rel="import" href="./modal.html">


<dom-module id="create-image-game">
  <template>
    <style>
    </style>
    <status-bar
      id="statusBar"
      title="{{localize('title')}}"
      score="{{localize('score')}}"
      lefted="{{localize('lefted')}}"
      hasname="{{handleCheckName()}}"
      total="{{total}}"
      point="{{point}}"
      matched="{{matched}}"
      purpose="select"
      cards="{{cards}}"
      on-modal="handleModal"
      fullscreen="{{localize('fullscreen')}}"
    ></status-bar>
    <svg id="createSvg"></svg>
  </template>
  <script>
    class CreateImageGame extends Polymer.mixinBehaviors([Polymer.AppLocalizeBehavior], Polymer.Element) {
      static get is() { return 'create-image-game'; }
      connectedCallback() {
        super.connectedCallback();
      }
      static get properties() {
        return {
          language: {
            value: "ko"
          }
        }
      }
      dragstarted(d) {
        let self = d3.select('#element').node(),
            newX = this.x.animVal.value,
            newY = this.y.animVal.value;

        self.set('startX', newX)
        self.set('startY', newY)
        d3.select(this).attr("x", d3.event.x-50).attr("y", d3.event.y-50);

        d3.select(this.parentElement).append('image').attr("xlink:href", this.href.animVal)
          .attr('width', `${128*0.6}`).attr('height', `${128*0.6}`)
          .attr('x', newX ).attr('y', newY )
          .call(d3.drag()
            .on("start", self.dragstarted)
            .on("drag", self.dragged)
            .on("end", self.dragended)
          );
      }
      dragged(d){
        d3.select(this).attr("x", d3.event.x-50).attr("y", d3.event.y-50);
      }
      dragended(d){
        console.log("dragended");
        let resetImage = this.dataset.board,
            self = d3.select('#element').node(),
            getX = resetImage ? d3.event.x : d3.event.x+self.boardWidth+self.startX,
            getY = resetImage ? d3.event.y : d3.event.y+self.circles[0].y.animVal.value;
        // debugger
        console.log(self.boardWidth, self.resImagesGabfromBorad);
        let targetEl, targetX, targetY, result,
            cir = [].slice.call(self.circles, 1, self.circles.length);
        cir.forEach(el => {
          const getEl = el.getBBox();
          // debugger
          // self.
          if(getEl.x < getX && getX < getEl.x + getEl.width && getEl.y < getY && getY < getEl.y + getEl.height) {
            // debugger
            console.log("dragended range true");
            targetEl = el;
            targetX = getEl.x;
            targetY = getEl.y;
            // debugger
          }
        })
        if(targetEl){
          console.log("targeted!!!");
          d3.select(this).remove()
          d3.select(self.shadowRoot).select("#board").append('image')
            .attr('data-board', true)
            .attr("xlink:href", this.href.animVal)
            .attr('width', `${128*0.6}`).attr('height', `${128*0.6}`)
            .attr("x", targetX-5 ).attr("y", targetY-5 )
            .call(d3.drag()
              .on("start", self.reDragstarted )
              .on("drag", self.dragged)
              .on("end", self.dragended)
            )

          // debugger
          // d3.select(this)
          //   .attr("x", targetX ).attr("y", targetY )
          //   .call(d3.drag()
          //     .on("start", self.reDragstarted )
          //     .on("drag", self.dragged)
          //     .on("end", self.dragended)
          //   )
        } else {
          d3.select(this).attr("x", self.startX ).attr("y", self.startY )
        }
        // console.log("dragended range true");

      }
      reDragstarted(d) {
        d3.select(this).attr("x", d3.event.x-50).attr("y", d3.event.y-50);
        console.log("reDragstarted");
      }
      setData(data, manifest){
        let { innerHeight, innerWidth } = window,
            svgHeight = innerHeight-this.$.statusBar.getBoundingClientRect().height,
            svg = d3.select(this.$.createSvg)
                    .attr('width', innerWidth)
                    .attr('height', svgHeight),
            boardWidth = innerWidth*0.6 > svgHeight ? svgHeight : innerWidth*0.6,
            resWidth = innerWidth*0.4;

        svg.selectAll('g').data(["board", "resImages"]).enter()
            .append('g').attr('id', (d, i) => d)
            .attr('width', (d, i) => d === "board" ? boardWidth : resWidth)
            .attr('height', svgHeight)
            .exit()

        let board = svg.select("#board"),
            resImages = svg.select("#resImages"),
            backgroundImg = manifest.find(d => d.background).src,
            resImagesData = manifest.filter(d => !d.background)

        board.attr('transform', "translate(0 , 0)")
        let boardImageCenter = (svgHeight-boardWidth)/2,
            boardImage = board.append('image').attr("xlink:href", backgroundImg)
             .attr('x', 0).attr('y', boardImageCenter)
             .attr('width', boardWidth)
             .attr('height', boardWidth)

        let reAxis = boardImage.node().getBBox().width/14;

        let cirGroup = board.selectAll('g')
             .data(data).enter()
             .append('g')

        cirGroup.append('circle')
           .attr('fill', 'gray')
           .attr("r", 5)
           .attr("cx", (d, i) => d[0]*reAxis )
           .attr("cy", (d, i) => boardImageCenter+d[1]*reAxis)

        cirGroup.append("circle")
            .attr("r", 30).attr("opacity", 0.0)
            .attr("cx", (d, i) => d[0]*reAxis )
            .attr("cy", (d, i) => boardImageCenter+d[1]*reAxis)

        this.set('circles', board.node().childNodes)

        let rangeXmit = Math.floor(resWidth/(128*0.6)), //3
            resNums = resImagesData.length;

        let axis = []
        for(var i = 0; i < 13; i++ ){
          for(var j = 0; j < 3; j++ ) {
            if(axis.length >= resNums) {
              break;
            }
            axis.push([i,j])
          }
        }

        resImages.selectAll('image').data(resImagesData).enter()
             .append('image').attr("xlink:href", (d, i) => d.src)
             .attr('width', `${128*0.6}`).attr('height', `${128*0.6}`)
             .attr('x', ( d, i ) => axis[i][1]*(128*0.6))
             .attr('y', ( d, i ) => axis[i][0]*(128*0.6))
             .call(d3.drag()
               .on("start", this.dragstarted)
               .on("drag", this.dragged)
               .on("end", this.dragended)
             );

         //FIXME : resImages.getBBox()에서 width 로 중앙정렬
         // debugger
         let resImagesGabfromBorad = (resWidth-resImages.node().getBBox().width)/2
         resImages.attr('transform', (d, i) => `translate(${boardWidth+resImagesGabfromBorad}, ${(svgHeight-boardWidth)/2})`)

         this.set('boardWidth', boardWidth)
         this.set('resImagesGabfromBorad', resImagesGabfromBorad)
      }
    }
    window.customElements.define(CreateImageGame.is, CreateImageGame);
  </script>
</dom-module>
